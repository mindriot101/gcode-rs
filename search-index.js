var searchIndex = {};
searchIndex["arrayvec"] = {"doc":"arrayvec provides the types `ArrayVec` and `ArrayString`:  array-backed vector and string types, which store their contents inline.","items":[[8,"RangeArgument","arrayvec","IndexRange is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[3,"ArrayString","","A string with a fixed capacity.",null,null],[3,"ArrayVec","","A vector with a fixed capacity.",null,null],[3,"IntoIter","","By-value iterator for `ArrayVec`.",null,null],[3,"Drain","","A draining iterator for `ArrayVec`.",null,null],[3,"CapacityError","","Error value indicating insufficient capacity",null,null],[11,"new","","Create a new empty `ArrayString`.",1,{"inputs":[],"output":{"name":"arraystring"}}],[11,"from","","Create a new `ArrayString` from a `str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_byte_string","","Create a new `ArrayString` from a byte string literal.",1,{"inputs":[{"name":"a"}],"output":{"name":"result"}}],[11,"capacity","","Return the capacity of the `ArrayString`.",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_full","","Return if the `ArrayString` is completely filled.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Adds the given char to the end of the string.",1,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"result"}}],[11,"push_str","","Adds the given string slice to the end of the string.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"clear","","Make the string empty.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"set_len","","Set the strings's length.",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"as_str","","Return a string slice of the whole `ArrayString`.",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref_mut","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"hash","","",1,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"borrow","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_ref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"write_char","","",1,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"result"}}],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"arraystring"}}],[11,"clone_from","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[8,"Array","","Trait for fixed size arrays.",null,null],[16,"Item","","The array's element type",2,null],[11,"drop","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create a new empty `ArrayVec`.",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"len","","Return the number of elements in the `ArrayVec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"capacity","","Return the capacity of the `ArrayVec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_full","","Return if the `ArrayVec` is completely filled.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Push `element` to the end of the vector.",3,null],[11,"insert","","Insert `element` in position `index`.",3,null],[11,"pop","","Remove the last element in the vector.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"swap_remove","","Remove the element at `index` and swap the last element into its place.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"remove","","Remove the element at `index` and shift down the following elements.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"clear","","Remove all elements in the vector.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"retain","","Retains only the elements specified by the predicate.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"set_len","","Set the vector's length without dropping or moving out elements",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"drain","","Create a draining iterator that removes the specified range in the vector and yields the removed items from start to end. The element range is removed even if the iterator is not consumed until the end.",3,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"drain"}}],[11,"into_inner","","Return the inner fixed size array, if it is full to its capacity.",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"dispose","","Dispose of `self` without the overwriting that is needed in Drop.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"as_slice","","Return a slice containing all elements of the vector.",3,null],[11,"as_mut_slice","","Return a mutable slice containing all elements of the vector.",3,null],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",3,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"into_iter","","",3,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop","","",4,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"extend","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone_from","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"hash","","",3,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",3,null],[11,"borrow","","",3,null],[11,"borrow_mut","","",3,null],[11,"as_ref","","",3,null],[11,"as_mut","","",3,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"arrayvec"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"self"},{"name":"arrayvec"}],"output":{"name":"ordering"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"capacityerror"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"ordering"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"element","","Extract the overflowing element",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"simplify","","Convert into a `CapacityError` that does not carry an element.",6,{"inputs":[{"name":"self"}],"output":{"name":"capacityerror"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[8,"RangeArgument"],[3,"ArrayString"],[8,"Array"],[3,"ArrayVec"],[3,"IntoIter"],[3,"Drain"],[3,"CapacityError"]]};
searchIndex["gcode"] = {"doc":"A crate for parsing gcodes without relying on `std`.","items":[[4,"Error","gcode","The error type.",null,null],[13,"UnknownToken","","Encountered an unknown token at a particular location.",0,null],[13,"UnexpectedEOF","","Reached the end of input, unexpectedly.",0,null],[13,"SyntaxError","","A syntax error and its location.",0,null],[13,"InvalidCommand","","During type-checking invalid command conditions were encountered.",0,null],[0,"low_level","","The first stage of parsing which turns tokens into a basic gcode representation.",null,null],[3,"BasicParser","gcode::low_level","A parser which takes a stream of characters and parses them as gcode instructions.",null,null],[3,"Command","","A gcode command.",null,null],[3,"Argument","","An argument for a gcode command.",null,null],[12,"kind","","What type of argument this is.",1,null],[12,"value","","Its value.",1,null],[4,"ArgumentKind","","",null,null],[13,"X","","",2,null],[13,"Y","","",2,null],[13,"Z","","",2,null],[13,"R","","",2,null],[13,"S","","",2,null],[13,"H","","",2,null],[13,"FeedRate","","",2,null],[13,"P","","",2,null],[13,"I","","",2,null],[13,"J","","",2,null],[13,"E","","",2,null],[4,"CommandType","","An enum representing the command type.",null,null],[13,"G","","A general G code.",3,null],[13,"M","","A M code.",3,null],[13,"T","","An instruction to change tools.",3,null],[4,"Line","","A line of gcode.",null,null],[13,"Cmd","","A gcode command.",4,null],[13,"ProgramNumber","","The program number.",4,null],[6,"ArgBuffer","","An argument buffer containing up to 10 Arguments.",null,null],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `BasicParser` from a token stream.",5,{"inputs":[{"name":"i"}],"output":{"name":"basicparser"}}],[11,"parse","","Parse the input and get the next line.",5,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"command"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"span","","Get the location of the `Command` in source code.",6,{"inputs":[{"name":"self"}],"output":{"name":"span"}}],[11,"line_number","","The line number as declared with `N123` (if provided).",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"command","","Loosely-typed representation of the command (e.g. `(G, 90)`).",6,null],[11,"args","","Get the arguments this command was invoked with.",6,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",6,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"argument"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"argument"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"argument"}],"output":{"name":"bool"}}],[11,"new","","Create a new argument.",1,{"inputs":[{"name":"argumentkind"},{"name":"f32"}],"output":{"name":"argument"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"argumentkind"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"argumentkind"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"commandtype"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"commandtype"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"line"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"line"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"line"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"lexer","gcode","A module for turning raw gcode into tokens to be processed by the parser.",null,null],[3,"Tokenizer","gcode::lexer","A zero-allocation tokenizer.",null,null],[3,"Token","","A gcode Token.",null,null],[3,"Span","","A representation of a position in source code.",null,null],[12,"line","","The line number (counting from zero).",7,null],[12,"column","","The column number (counting from zero).",7,null],[4,"TokenKind","","A `gcode` token.",null,null],[13,"Number","","A floating point number.",8,null],[13,"G","","",8,null],[13,"T","","",8,null],[13,"N","","",8,null],[13,"O","","",8,null],[13,"X","","",8,null],[13,"Y","","",8,null],[13,"Z","","",8,null],[13,"FeedRate","","",8,null],[13,"M","","",8,null],[13,"S","","",8,null],[13,"R","","",8,null],[13,"H","","",8,null],[13,"P","","",8,null],[13,"I","","",8,null],[13,"J","","",8,null],[13,"E","","",8,null],[13,"Minus","","",8,null],[13,"Percent","","",8,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Tokenizer` from some `char` iterator.",9,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"kind","","Which kind of token is this?",10,{"inputs":[{"name":"self"}],"output":{"name":"tokenkind"}}],[11,"span","","Get the location of the token in the source code.",10,{"inputs":[{"name":"self"}],"output":{"name":"span"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"tokenkind"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"span"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",7,{"inputs":[],"output":{"name":"span"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"span"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"span"}],"output":{"name":"bool"}}],[11,"from","","",7,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"bool"}}],[11,"from","","",10,{"inputs":[{"name":"tokenkind"}],"output":{"name":"self"}}],[0,"parser","gcode","The main parsing module for this crate.",null,null],[3,"Parser","gcode::parser","A parser which turns a stream of gcode tokens into a stream of commands.",null,null],[3,"Command","","A single command.",null,null],[12,"kind","","Which kind of `Command` is this?",11,null],[12,"number","","The command's number.",11,null],[12,"args","","All arguments passed to the command.",11,null],[12,"line_number","","The line number the command is on (if any).",11,null],[3,"Args","","A good ol' bag-o-floats which contains all the possible arguments and their values.",null,null],[12,"x","","",12,null],[12,"y","","",12,null],[12,"z","","",12,null],[12,"s","","",12,null],[12,"t","","",12,null],[12,"f","","",12,null],[12,"i","","",12,null],[12,"j","","",12,null],[12,"h","","",12,null],[12,"p","","",12,null],[12,"e","","",12,null],[4,"Line","","A single line of gcode.",null,null],[13,"ProgramNumber","","A program number.",13,null],[13,"Cmd","","An actual command.",13,null],[4,"Number","","A type which can either be an integer or a float.",null,null],[13,"Integer","","A plain integer.",14,null],[13,"Decimal","","A floating point number, represented as the integer before and after the decimal point.",14,null],[4,"CommandKind","","The type of command.",null,null],[13,"G","","",15,null],[13,"M","","",15,null],[13,"T","","",15,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new parser using the provided stream of tokens.",16,{"inputs":[{"name":"i"}],"output":{"name":"parser"}}],[11,"next","","",16,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"line"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"line"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"line"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"number"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"number"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"number"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"command"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"command"}],"output":{"name":"bool"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"args"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"args"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"args"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"args"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"commandkind"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"commandkind"}],"output":{"name":"bool"}}],[11,"fmt","gcode","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[6,"Result","","An alias for the `Result` type.",null,null]],"paths":[[4,"Error"],[3,"Argument"],[4,"ArgumentKind"],[4,"CommandType"],[4,"Line"],[3,"BasicParser"],[3,"Command"],[3,"Span"],[4,"TokenKind"],[3,"Tokenizer"],[3,"Token"],[3,"Command"],[3,"Args"],[4,"Line"],[4,"Number"],[4,"CommandKind"],[3,"Parser"]]};
searchIndex["nodrop"] = {"doc":"","items":[[3,"NoDrop","nodrop","A type holding T that will not call its destructor on drop",null,null],[11,"new","","Create a new NoDrop.",0,{"inputs":[{"name":"t"}],"output":{"name":"nodrop"}}],[11,"into_inner","","Extract the inner value.",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",0,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}]],"paths":[[3,"NoDrop"]]};
searchIndex["odds"] = {"doc":"Odds and ends — collection miscellania.","items":[[3,"Fix","odds","Fixpoint combinator for rust closures, generalized over the return type.",null,null],[12,"0","","",0,null],[5,"fix","","Fixpoint combinator for rust closures, generalized over the return type.",null,{"inputs":[{"name":"t"},{"name":"f"}],"output":{"name":"r"}}],[5,"ref_eq","","Compare if a and b are equal as pointers.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"ptr_eq","","Compare if a and b are equal pointers.",null,null],[5,"raw_byte_repr","","Safe to use with any wholly initialized memory `ptr`",null,null],[5,"get_unchecked","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"get_unchecked_mut","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"debug_assert_unreachable","","Act as `debug_assert!` in debug mode, asserting that this point is not reached.",null,null],[5,"slice_unchecked","","Check slicing bounds in debug mode, otherwise just act as an unchecked slice call.",null,null],[5,"slice_unchecked_mut","","Check slicing bounds in debug mode, otherwise just act as an unchecked slice call.",null,null],[5,"ref_slice","","Create a length 1 slice out of a reference",null,null],[5,"ref_slice_mut","","Create a length 1 mutable slice out of a reference",null,null],[11,"call","","",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"r"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[0,"char","","Extra functions for `char`",null,null],[3,"EncodeUtf8Error","odds::char","Placeholder",null,null],[5,"encode_utf8","","Encode a char into buf using UTF-8.",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"encodeutf8error"}}],[0,"string","odds","Extensions to `&str` and `String`",null,null],[3,"Prefixes","odds::string","Iterator of all non-empty prefixes",null,null],[3,"Suffixes","","Iterator of all non-empty suffixes",null,null],[3,"Substrings","","Iterator of all non-empty substrings",null,null],[3,"CharChunks","","An iterator that splits the string in substrings of each `n` `char` per substring. The last item will contain the remainder if `n` does not divide the char length of the string evenly.",null,null],[3,"CharWindows","","An iterator that produces substrings of each `n` `char` per substring in a sliding window that advances one char at a time.",null,null],[3,"CharStr","","A single-char string.",null,null],[8,"StrExt","","Extra methods for `str`",null,null],[10,"prefixes","","All non-empty prefixes",2,{"inputs":[{"name":"self"}],"output":{"name":"prefixes"}}],[10,"suffixes","","All non-empty suffixes",2,{"inputs":[{"name":"self"}],"output":{"name":"suffixes"}}],[10,"substrings","","Produce all non-empty substrings",2,{"inputs":[{"name":"self"}],"output":{"name":"substrings"}}],[10,"is_acceptable_index","","Return `true` if `index` is acceptable for slicing the string.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[8,"StrSlice","","Extension trait for `str` for string slicing without panicking",null,null],[10,"get_slice","","Return a slice of the string, if it is in bounds /and on character boundaries/, otherwise return `None`",3,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"option"}}],[8,"StrChunksWindows","","Extension traits for the `char_chunks` and `char_windows` methods",null,null],[10,"char_chunks","","Return an iterator that splits the string in substrings of each `n` `char` per substring. The last item will contain the remainder if `n` does not divide the char length of the string evenly.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"charchunks"}}],[10,"char_windows","","Return an iterator that produces substrings of each `n` `char` per substring in a sliding window that advances one char at a time.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"charwindows"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"prefixes"}}],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"suffixes"}}],[11,"next","","",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"substrings"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"charchunks"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"charwindows"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"charstr"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new string from `c`.",10,{"inputs":[{"name":"char"}],"output":{"name":"charstr"}}],[11,"deref","","",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"slice","odds","Extra functions for slices",null,null],[3,"MendSlices","odds::slice","An iterator adaptor that glues together adjacent contiguous slices.",null,null],[3,"RevSlice","","A reversed view of a slice.",null,null],[5,"shared_prefix","","Return the end index of the longest shared (equal) prefix of `a` and `b`.",null,null],[5,"rotate_left","","Rotate `steps` towards lower indices.",null,null],[5,"split_aligned_for","","Split the input slice into three chunks, so that the middle chunk is a slice of a larger \"block size\" (for example T could be u64) that is correctly aligned for `T`.",null,null],[0,"unalign","","",null,null],[3,"UnalignedIter","odds::slice::unalign","An iterator of `T` (by value) where each value read using an unaligned load.",null,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"from_raw_parts","","Create an `UnalignedIter` from `ptr` and `end`, which must be spaced an whole number of `T` offsets apart.",11,null],[11,"from_slice","","Create an `UnalignedIter` out of the slice of data, which iterates first in blocks of `T` (unaligned loads), and then leaves a tail of the remaining bytes.",11,null],[11,"tail","","Return a byte iterator of the remaining tail of the iterator; this can be called at any time, but in particular when the iterator has returned None.",11,{"inputs":[{"name":"self"}],"output":{"name":"slicecopyiter"}}],[11,"has_tail","","Return `true` if the tail is not empty.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"peek_next","","Return the next iterator element, without stepping the iterator.",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"iter","odds::slice","",null,null],[3,"SliceCopyIter","odds::slice::iter","Slice (contiguous data) iterator.",null,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","",12,null],[11,"into_raw","","Return the start, end pointer of the iterator",12,null],[11,"next","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",12,null],[11,"count","","",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",12,null],[11,"default","","Create an empty `SliceCopyIter`.",12,{"inputs":[],"output":{"name":"self"}}],[8,"SliceFind","odds::slice","Element-finding methods for slices",null,null],[16,"Item","","",13,null],[10,"find","","Linear search for the first occurrence  `elt` in the slice.",13,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[10,"rfind","","Linear search for the last occurrence  `elt` in the slice.",13,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[8,"SliceFindSplit","","Element-finding methods for slices",null,null],[16,"Item","","",14,null],[10,"find_split","","Linear search for the first occurrence  `elt` in the slice.",14,null],[10,"rfind_split","","Linear search for the last occurrence  `elt` in the slice.",14,null],[10,"find_split_mut","","Linear search for the first occurrence  `elt` in the slice.",14,null],[10,"rfind_split_mut","","Linear search for the last occurrence  `elt` in the slice.",14,null],[8,"SliceIterExt","","Extra iterator adaptors for iterators of slice elements.",null,null],[11,"mend_slices","","Return an iterator adaptor that joins together adjacent slices if possible.",15,{"inputs":[{"name":"self"}],"output":{"name":"mendslices"}}],[8,"MendSlice","","A trait for items that can maybe be joined together.",null,null],[8,"Pod","","\"plain old data\": Types that we can stick arbitrary bit patterns into, and thus use them as blocks in `split_aligned_for` or in `UnalignedIter`.",null,null],[11,"find","","",16,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[11,"rfind","","",16,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","Create a new `MendSlices`.",17,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",17,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"len","","Return the length of the slice.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Get element at index `i`.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_mut","","Get element at index `i`.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"inner_ref","","",16,null],[11,"inner_mut","","",16,null],[11,"iter","","Return a by-reference iterator",16,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"iter_mut","","Return a by-mutable-reference iterator",16,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"split_at","","",16,null],[11,"split_at_mut","","",16,null],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"revslice"}],"output":{"name":"bool"}}],[11,"eq","","",16,null],[11,"hash","","",16,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"index","","",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index_mut","","",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index","","",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"revslice"}}],[11,"index_mut","","",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"revslice"}}],[0,"stride","odds","Slice iterator with custom step size",null,null],[3,"Stride","odds::stride","(the stride) skipped per iteration.",null,null],[3,"StrideMut","","The mutable equivalent of Stride.",null,null],[11,"from_ptr_len","","Create a Stride iterator from a raw pointer.",18,null],[11,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",19,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",18,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",18,{"inputs":[{"name":"stride"},{"name":"isize"}],"output":{"name":"stride"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride, in effect reversing the iterator.",18,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Return the number of elements in the iterator.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Return a reference to the element of a stride at the given index, or None if the index is out of bounds.",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",18,null],[11,"next_back","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"index","","Return a reference to the element at a given index.",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",19,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",19,{"inputs":[{"name":"stridemut"},{"name":"isize"}],"output":{"name":"stridemut"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride, in effect reversing the iterator.",19,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Return the number of elements in the iterator.",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Return a reference to the element of a stride at the given index, or None if the index is out of bounds.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",19,null],[11,"next_back","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"index","","Return a reference to the element at a given index.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"stride"}}],[11,"get_mut","","Return a mutable reference to the element of a stride at the given index, or None if the index is out of bounds.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"index_mut","","Return a mutable reference to the element at a given index.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[0,"prelude","odds","prelude of often used traits and functions",null,null],[8,"IndexRange","","IndexRange is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"start","","Start index (inclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[3,"Fix"],[3,"EncodeUtf8Error"],[8,"StrExt"],[8,"StrSlice"],[8,"StrChunksWindows"],[3,"Prefixes"],[3,"Suffixes"],[3,"Substrings"],[3,"CharChunks"],[3,"CharWindows"],[3,"CharStr"],[3,"UnalignedIter"],[3,"SliceCopyIter"],[8,"SliceFind"],[8,"SliceFindSplit"],[8,"SliceIterExt"],[3,"RevSlice"],[3,"MendSlices"],[3,"Stride"],[3,"StrideMut"],[8,"IndexRange"]]};
initSearch(searchIndex);
